// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_H_
#define CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_H_
#pragma once

// A class that encapsulates the detailed malware reports sent when
// users opt-in to do so from the malware warning page.

// An instance of this class is generated when a malware warning page
// is shown (SafeBrowsingBlockingPage). It is passed on to the
// SafeBrowsing service when the warning goes away.

#include <string>
#include <vector>

#include "base/hash_tables.h"
#include "base/linked_ptr.h"
#include "base/scoped_ptr.h"
#include "chrome/browser/safe_browsing/report.pb.h"
#include "chrome/browser/safe_browsing/safe_browsing_service.h"
#include "content/browser/tab_contents/tab_contents_observer.h"

class TabContents;
struct ViewHostMsg_MalwareDOMDetails_Params;

class MalwareDetailsFactory;

class MalwareDetails : public base::RefCountedThreadSafe<MalwareDetails>,
                       public TabContentsObserver {
 public:
  // Constructs a new MalwareDetails instance, using the factory.
  static MalwareDetails* NewMalwareDetails(
      TabContents* tab_contents,
      const SafeBrowsingService::UnsafeResource& resource);

  // Makes the passed |factory| the factory used to instanciate
  // SafeBrowsingBlockingPage objects. Useful for tests.
  static void RegisterFactory(MalwareDetailsFactory* factory) {
    factory_ = factory;
  }

  // The SafeBrowsingService calls this from the IO thread, to get the
  // serialized report as a string and send it over.
  const std::string* GetSerializedReport();

  // TabContentsObserver implementation.
  virtual bool OnMessageReceived(const IPC::Message& message);

 protected:
  friend class MalwareDetailsFactoryImpl;

  MalwareDetails(TabContents* tab_contents,
                 const SafeBrowsingService::UnsafeResource resource);

  // Called on the IO thread with the DOM details.
  virtual void AddDOMDetails(
      const ViewHostMsg_MalwareDOMDetails_Params& params);

  virtual ~MalwareDetails();

 private:
  friend class base::RefCountedThreadSafe<MalwareDetails>;

  // Maps a URL to its Resource.
  typedef base::hash_map<
    std::string,
    linked_ptr<safe_browsing::ClientMalwareReportRequest::Resource> >
  ResourceMap;

  // Starts the collection of the report.
  void StartCollection();

  // Whether the url is "public" so we can add it to the report.
  bool IsPublicUrl(const GURL& url) const;

  // Finds an existing Resource for the given url, or creates a new
  // one if not found, and adds it to |resources_|. Returns the
  // found/created resource.
  safe_browsing::ClientMalwareReportRequest::Resource* FindOrCreateResource(
      const GURL& url);

  // Adds a Resource to resources_ with the given parent-child
  // relationship. |parent| and |tagname| can be empty, |children| can be NULL.
  void AddUrl(const GURL& url,
              const GURL& parent,
              const std::string& tagname,
              const std::vector<GURL>* children);

  // Message handler.
  void OnReceivedMalwareDOMDetails(
      const ViewHostMsg_MalwareDOMDetails_Params& params);

  const SafeBrowsingService::UnsafeResource resource_;

  // For every Url we collect we create a Resource message. We keep
  // them in a map so we can avoid duplicates.
  ResourceMap resources_;

  // The report protocol buffer.
  scoped_ptr<safe_browsing::ClientMalwareReportRequest> report_;

  // The factory used to instanciate SafeBrowsingBlockingPage objects.
  // Usefull for tests, so they can provide their own implementation of
  // SafeBrowsingBlockingPage.
  static MalwareDetailsFactory* factory_;

  FRIEND_TEST_ALL_PREFIXES(MalwareDetailsTest, MalwareDOMDetails);

  DISALLOW_COPY_AND_ASSIGN(MalwareDetails);
};

// Factory for creating MalwareDetails.  Useful for tests.
class MalwareDetailsFactory {
 public:
  virtual ~MalwareDetailsFactory() { }

  virtual MalwareDetails* CreateMalwareDetails(
      TabContents* tab_contents,
      const SafeBrowsingService::UnsafeResource& unsafe_resource) = 0;
};

#endif  // CHROME_BROWSER_SAFE_BROWSING_MALWARE_DETAILS_H_
