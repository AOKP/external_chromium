// This file was GENERATED by command:
//     pump.py bind_internal.h.pump
// DO NOT EDIT BY HAND!!!


// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef BASE_BIND_INTERNAL_H_
#define BASE_BIND_INTERNAL_H_
#pragma once

#include "base/bind_helpers.h"
#include "base/callback_helpers.h"
#include "base/template_util.h"

namespace base {
namespace internal {

// The method by which a function is invoked is determined by 3 different
// dimensions:
//
//   1) The type of function (normal, method, const-method)
//   2) The arity of the function
//   3) The number of bound parameters.
//
// The FunctionTraitsN classes unwrap the function signature type to
// specialize based on the first two dimensions.  The N in FunctionTraitsN
// specifies the 3rd dimension.  We could have specified the unbound parameters
// via template parameters, but this method looked cleaner.
//
// The FunctionTraitsN contains a static DoInvoke() function that is the key to
// implementing type erasure in the Callback() classes.  DoInvoke() is a static
// function with a fixed signature that is independent of StorageType; its
// first argument is a pointer to the non-templated common baseclass of
// StorageType. This lets us store pointer to DoInvoke() in a function pointer
// that has knowledge of the specific StorageType, and thus no knowledge of the
// bound function and bound parameter types.
//
// As long as we ensure that DoInvoke() is only used with pointers there were
// upcasted from the correct StorageType, we can be sure that execution is
// safe.

template <typename StorageType, typename Sig>
struct FunctionTraits0;

// Function: Arity 0 -> 0.
template <typename StorageType, typename R>
struct FunctionTraits0<StorageType, R(*)()> {
  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_();
  }
};

// Function: Arity 1 -> 1.
template <typename StorageType, typename R,typename X1>
struct FunctionTraits0<StorageType, R(*)(X1)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1);
  }
};

// Function: Arity 2 -> 2.
template <typename StorageType, typename R,typename X1, typename X2>
struct FunctionTraits0<StorageType, R(*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1, x2);
  }
};

// Function: Arity 3 -> 3.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3>
struct FunctionTraits0<StorageType, R(*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1, x2, x3);
  }
};

// Function: Arity 4 -> 4.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4>
struct FunctionTraits0<StorageType, R(*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1, x2, x3, x4);
  }
};

// Function: Arity 5 -> 5.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits0<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3, const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1, x2, x3, x4, x5);
  }
};

// Function: Arity 6 -> 6.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits0<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3, const X4& x4, const X5& x5, const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(x1, x2, x3, x4, x5, x6);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits1;

// Function: Arity 1 -> 0.
template <typename StorageType, typename R,typename X1>
struct FunctionTraits1<StorageType, R(*)(X1)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_));
  }
};

// Method: Arity 0 -> 0.
template <typename StorageType, typename R, typename T>
struct FunctionTraits1<StorageType, R(T::*)()> {
  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)();
  }
};

// Const Method: Arity 0 -> 0.
template <typename StorageType, typename R, typename T>
struct FunctionTraits1<StorageType, R(T::*)() const> {
  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)();
  }
};

// Function: Arity 2 -> 1.
template <typename StorageType, typename R,typename X1, typename X2>
struct FunctionTraits1<StorageType, R(*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), x2);
  }
};

// Method: Arity 1 -> 1.
template <typename StorageType, typename R, typename T, typename X1>
struct FunctionTraits1<StorageType, R(T::*)(X1)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1);
  }
};

// Const Method: Arity 1 -> 1.
template <typename StorageType, typename R, typename T, typename X1>
struct FunctionTraits1<StorageType, R(T::*)(X1) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X1& x1) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1);
  }
};

// Function: Arity 3 -> 2.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3>
struct FunctionTraits1<StorageType, R(*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), x2, x3);
  }
};

// Method: Arity 2 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2);
  }
};

// Const Method: Arity 2 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X1& x1, const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2);
  }
};

// Function: Arity 4 -> 3.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4>
struct FunctionTraits1<StorageType, R(*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3,
      const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), x2, x3, x4);
  }
};

// Method: Arity 3 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3);
  }
};

// Const Method: Arity 3 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X1& x1, const X2& x2,
      const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3);
  }
};

// Function: Arity 5 -> 4.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits1<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3,
      const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), x2, x3, x4, x5);
  }
};

// Method: Arity 4 -> 4.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3, x4);
  }
};

// Const Method: Arity 4 -> 4.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3, X4) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X1& x1, const X2& x2,
      const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3, x4);
  }
};

// Function: Arity 6 -> 5.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits1<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3,
      const X4& x4, const X5& x5, const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), x2, x3, x4, x5, x6);
  }
};

// Method: Arity 5 -> 5.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X1& x1, const X2& x2,
      const X3& x3, const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3, x4, x5);
  }
};

// Const Method: Arity 5 -> 5.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits1<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X1& x1, const X2& x2,
      const X3& x3, const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(x1, x2, x3, x4, x5);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits2;

// Function: Arity 2 -> 0.
template <typename StorageType, typename R,typename X1, typename X2>
struct FunctionTraits2<StorageType, R(*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_));
  }
};

// Method: Arity 1 -> 0.
template <typename StorageType, typename R, typename T, typename X1>
struct FunctionTraits2<StorageType, R(T::*)(X1)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_));
  }
};

// Const Method: Arity 1 -> 0.
template <typename StorageType, typename R, typename T, typename X1>
struct FunctionTraits2<StorageType, R(T::*)(X1) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_));
  }
};

// Function: Arity 3 -> 1.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3>
struct FunctionTraits2<StorageType, R(*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_), x3);
  }
};

// Method: Arity 2 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2);
  }
};

// Const Method: Arity 2 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X2& x2) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2);
  }
};

// Function: Arity 4 -> 2.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4>
struct FunctionTraits2<StorageType, R(*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_), x3, x4);
  }
};

// Method: Arity 3 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3);
  }
};

// Const Method: Arity 3 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X2& x2, const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3);
  }
};

// Function: Arity 5 -> 3.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits2<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3, const X4& x4,
      const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_), x3, x4, x5);
  }
};

// Method: Arity 4 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3,
      const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3,
        x4);
  }
};

// Const Method: Arity 4 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3, X4) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X2& x2, const X3& x3,
      const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3,
        x4);
  }
};

// Function: Arity 6 -> 4.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits2<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3, const X4& x4,
      const X5& x5, const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_), x3, x4, x5,
        x6);
  }
};

// Method: Arity 5 -> 4.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X2& x2, const X3& x3,
      const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3,
        x4, x5);
  }
};

// Const Method: Arity 5 -> 4.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits2<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X2& x2, const X3& x3,
      const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_), x2, x3,
        x4, x5);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits3;

// Function: Arity 3 -> 0.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3>
struct FunctionTraits3<StorageType, R(*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_));
  }
};

// Method: Arity 2 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_));
  }
};

// Const Method: Arity 2 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_));
  }
};

// Function: Arity 4 -> 1.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4>
struct FunctionTraits3<StorageType, R(*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x4);
  }
};

// Method: Arity 3 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3);
  }
};

// Const Method: Arity 3 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X3& x3) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3);
  }
};

// Function: Arity 5 -> 2.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits3<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x4, x5);
  }
};

// Method: Arity 4 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3, x4);
  }
};

// Const Method: Arity 4 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3, X4) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X3& x3, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3, x4);
  }
};

// Function: Arity 6 -> 3.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits3<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X4& x4, const X5& x5,
      const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x4, x5, x6);
  }
};

// Method: Arity 5 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X3& x3, const X4& x4,
      const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3, x4, x5);
  }
};

// Const Method: Arity 5 -> 3.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits3<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X3& x3, const X4& x4,
      const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), x3, x4, x5);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits4;

// Function: Arity 4 -> 0.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4>
struct FunctionTraits4<StorageType, R(*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_));
  }
};

// Method: Arity 3 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_));
  }
};

// Const Method: Arity 3 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_));
  }
};

// Function: Arity 5 -> 1.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits4<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x5);
  }
};

// Method: Arity 4 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x4);
  }
};

// Const Method: Arity 4 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3, X4) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X4& x4) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x4);
  }
};

// Function: Arity 6 -> 2.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits4<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X5& x5, const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x5, x6);
  }
};

// Method: Arity 5 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x4, x5);
  }
};

// Const Method: Arity 5 -> 2.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits4<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X4& x4, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), x4, x5);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits5;

// Function: Arity 5 -> 0.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5>
struct FunctionTraits5<StorageType, R(*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_));
  }
};

// Method: Arity 4 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits5<StorageType, R(T::*)(X1, X2, X3, X4)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_));
  }
};

// Const Method: Arity 4 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4>
struct FunctionTraits5<StorageType, R(T::*)(X1, X2, X3, X4) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_));
  }
};

// Function: Arity 6 -> 1.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits5<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X6& x6) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_), x6);
  }
};

// Method: Arity 5 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits5<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base, const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_), x5);
  }
};

// Const Method: Arity 5 -> 1.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits5<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base,  const X5& x5) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_), x5);
  }
};

template <typename StorageType, typename Sig>
struct FunctionTraits6;

// Function: Arity 6 -> 0.
template <typename StorageType, typename R,typename X1, typename X2,
    typename X3, typename X4, typename X5, typename X6>
struct FunctionTraits6<StorageType, R(*)(X1, X2, X3, X4, X5, X6)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ||
          is_non_const_reference<X6>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::false_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return invoker->f_(Unwrap(invoker->p1_), Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_),
        Unwrap(invoker->p6_));
  }
};

// Method: Arity 5 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits6<StorageType, R(T::*)(X1, X2, X3, X4, X5)> {
  COMPILE_ASSERT(
      !( is_non_const_reference<X1>::value ||
          is_non_const_reference<X2>::value ||
          is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_),
        Unwrap(invoker->p6_));
  }
};

// Const Method: Arity 5 -> 0.
template <typename StorageType, typename R, typename T, typename X1,
    typename X2, typename X3, typename X4, typename X5>
struct FunctionTraits6<StorageType, R(T::*)(X1, X2, X3, X4, X5) const> {
  COMPILE_ASSERT(
      !(is_non_const_reference<X1>::value || is_non_const_reference<X2>::value
          || is_non_const_reference<X3>::value ||
          is_non_const_reference<X4>::value ||
          is_non_const_reference<X5>::value ),
      do_not_bind_functions_with_nonconst_ref);

  typedef base::true_type IsMethod;

  static R DoInvoke(InvokerStorageBase* base ) {
    StorageType* invoker = static_cast<StorageType*>(base);
    return (Unwrap(invoker->p1_)->*invoker->f_)(Unwrap(invoker->p2_),
        Unwrap(invoker->p3_), Unwrap(invoker->p4_), Unwrap(invoker->p5_),
        Unwrap(invoker->p6_));
  }
};


// These are the actual storage classes for the invokers.
//
// Though these types are "classes", they are being used as structs with
// all member variable public.  We cannot make it a struct because it inherits
// from a class which causes a compiler warning.  We cannot add a "Run()" method
// that forwards the unbound arguments because that would require we unwrap the
// Sig type like in FunctionTraitsN above to know the return type, and the arity
// of Run().
//
// An alternate solution would be to merge FunctionTraitsN and InvokerStorageN,
// but the generated code seemed harder to read.

template <typename Sig>
class InvokerStorage0 : public InvokerStorageBase {
 public:
  typedef InvokerStorage0 StorageType;
  typedef FunctionTraits0<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;



  InvokerStorage0(Sig f)
      : f_(f) {
  }

  virtual ~InvokerStorage0() {  }

  Sig f_;
};

template <typename Sig, typename P1>
class InvokerStorage1 : public InvokerStorageBase {
 public:
  typedef InvokerStorage1 StorageType;
  typedef FunctionTraits1<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);


  InvokerStorage1(Sig f, const P1& p1)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage1() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
};

template <typename Sig, typename P1, typename P2>
class InvokerStorage2 : public InvokerStorageBase {
 public:
  typedef InvokerStorage2 StorageType;
  typedef FunctionTraits2<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P2>::value,
                 p2_is_refcounted_type_and_needs_scoped_refptr);


  InvokerStorage2(Sig f, const P1& p1, const P2& p2)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)),
          p2_(static_cast<typename BindType<P2>::StorageType>(p2)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage2() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
  typename BindType<P2>::StorageType p2_;
};

template <typename Sig, typename P1, typename P2, typename P3>
class InvokerStorage3 : public InvokerStorageBase {
 public:
  typedef InvokerStorage3 StorageType;
  typedef FunctionTraits3<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P2>::value,
                 p2_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P3>::value,
                 p3_is_refcounted_type_and_needs_scoped_refptr);


  InvokerStorage3(Sig f, const P1& p1, const P2& p2, const P3& p3)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)),
          p2_(static_cast<typename BindType<P2>::StorageType>(p2)),
          p3_(static_cast<typename BindType<P3>::StorageType>(p3)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage3() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
  typename BindType<P2>::StorageType p2_;
  typename BindType<P3>::StorageType p3_;
};

template <typename Sig, typename P1, typename P2, typename P3, typename P4>
class InvokerStorage4 : public InvokerStorageBase {
 public:
  typedef InvokerStorage4 StorageType;
  typedef FunctionTraits4<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P2>::value,
                 p2_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P3>::value,
                 p3_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P4>::value,
                 p4_is_refcounted_type_and_needs_scoped_refptr);


  InvokerStorage4(Sig f, const P1& p1, const P2& p2, const P3& p3, const P4& p4)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)),
          p2_(static_cast<typename BindType<P2>::StorageType>(p2)),
          p3_(static_cast<typename BindType<P3>::StorageType>(p3)),
          p4_(static_cast<typename BindType<P4>::StorageType>(p4)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage4() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
  typename BindType<P2>::StorageType p2_;
  typename BindType<P3>::StorageType p3_;
  typename BindType<P4>::StorageType p4_;
};

template <typename Sig, typename P1, typename P2, typename P3, typename P4,
    typename P5>
class InvokerStorage5 : public InvokerStorageBase {
 public:
  typedef InvokerStorage5 StorageType;
  typedef FunctionTraits5<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P2>::value,
                 p2_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P3>::value,
                 p3_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P4>::value,
                 p4_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P5>::value,
                 p5_is_refcounted_type_and_needs_scoped_refptr);


  InvokerStorage5(Sig f, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4, const P5& p5)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)),
          p2_(static_cast<typename BindType<P2>::StorageType>(p2)),
          p3_(static_cast<typename BindType<P3>::StorageType>(p3)),
          p4_(static_cast<typename BindType<P4>::StorageType>(p4)),
          p5_(static_cast<typename BindType<P5>::StorageType>(p5)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage5() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
  typename BindType<P2>::StorageType p2_;
  typename BindType<P3>::StorageType p3_;
  typename BindType<P4>::StorageType p4_;
  typename BindType<P5>::StorageType p5_;
};

template <typename Sig, typename P1, typename P2, typename P3, typename P4,
    typename P5, typename P6>
class InvokerStorage6 : public InvokerStorageBase {
 public:
  typedef InvokerStorage6 StorageType;
  typedef FunctionTraits6<StorageType, Sig> FunctionTraits;
  typedef typename FunctionTraits::IsMethod IsMethod;

  // For methods, we need to be careful for parameter 1.  We skip the
  // scoped_refptr check because the binder itself takes care of this. We also
  // disallow binding of an array as the method's target object.
  COMPILE_ASSERT(IsMethod::value ||
                 !internal::UnsafeBindtoRefCountedArg<P1>::value,
                 p1_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!IsMethod::value || !is_array<P1>::value,
                 first_bound_argument_to_method_cannot_be_array);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P2>::value,
                 p2_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P3>::value,
                 p3_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P4>::value,
                 p4_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P5>::value,
                 p5_is_refcounted_type_and_needs_scoped_refptr);
  COMPILE_ASSERT(!internal::UnsafeBindtoRefCountedArg<P6>::value,
                 p6_is_refcounted_type_and_needs_scoped_refptr);


  InvokerStorage6(Sig f, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4, const P5& p5, const P6& p6)
      : f_(f), p1_(static_cast<typename BindType<P1>::StorageType>(p1)),
          p2_(static_cast<typename BindType<P2>::StorageType>(p2)),
          p3_(static_cast<typename BindType<P3>::StorageType>(p3)),
          p4_(static_cast<typename BindType<P4>::StorageType>(p4)),
          p5_(static_cast<typename BindType<P5>::StorageType>(p5)),
          p6_(static_cast<typename BindType<P6>::StorageType>(p6)) {
    MaybeRefcount<IsMethod, P1>::AddRef(p1_);
  }

  virtual ~InvokerStorage6() {
    MaybeRefcount<IsMethod, P1>::Release(p1_);
  }

  Sig f_;
  typename BindType<P1>::StorageType p1_;
  typename BindType<P2>::StorageType p2_;
  typename BindType<P3>::StorageType p3_;
  typename BindType<P4>::StorageType p4_;
  typename BindType<P5>::StorageType p5_;
  typename BindType<P6>::StorageType p6_;
};

}  // namespace internal
}  // namespace base

#endif  // BASE_BIND_INTERNAL_H_
